/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
package ca.thefriendlycoder.spockpertestlogger

import ca.thefriendlycoder.spockpertestlogger.samples.FeatureSetupTeardown
import ca.thefriendlycoder.spockpertestlogger.samples.MultiFeatureTest
import ca.thefriendlycoder.spockpertestlogger.samples.PassFailTest
import ca.thefriendlycoder.spockpertestlogger.samples.SimpleDataTest
import ca.thefriendlycoder.spockpertestlogger.samples.SimpleUnrolledDataTest
import ca.thefriendlycoder.spockpertestlogger.samples.SpecSetupTeardown
import ca.thefriendlycoder.spockpertestlogger.samples.SimpleTest
import spock.lang.PendingFeature
import spock.lang.Specification
import spock.lang.Subject
import spock.lang.TempDir
import spock.util.EmbeddedSpecRunner

import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths

@Subject(SpockPerTestLoggerExtension)
class SpockPerTestLoggerExtensionTest extends Specification {
    @TempDir
    Path tempdir

    def "Test log folder gets created"() {
        given: "A temp folder that doesn't already exist"
        def expPath = tempdir.resolve("fubar")

        and: "A sample Spock test spec"
        def specRunner = new EmbeddedSpecRunner()
        specRunner.throwFailure = false
        specRunner.configurationScript {
            PerTestLogger {
                logPath expPath.toString()
            }
        }

        when: "We try running the sample spec"
        def results = specRunner.runClass(SimpleTest)

        then: "The test suite should succeed without error"
        results.testEvents()
            .debug()
            .assertStatistics(stats -> stats.failed(0))

        and: "The log folder should have been created by the plugin"
        expPath.toFile().exists()
    }

    def "Test log folder already exists"() {
        given: "A temp folder that already exists"
        def expPath = tempdir.resolve("fubar")
        Files.createDirectories(expPath)

        and: "A sample Spock test spec"
        def specRunner = new EmbeddedSpecRunner()
        specRunner.throwFailure = false
        specRunner.configurationScript {
            PerTestLogger {
                logPath expPath.toString()
            }
        }

        when: "We try running the sample spec"
        def results = specRunner.runClass(SimpleTest)

        then: "The test suite should succeed without error"
        results.testEvents()
            .debug()
            .assertStatistics(stats -> stats.failed(0))
    }

    def "Test log file gets created"() {
        given: "A sample Spock test spec"
        def specRunner = new EmbeddedSpecRunner()
        specRunner.throwFailure = false
        specRunner.configurationScript {
            PerTestLogger {
                logPath tempdir.toString()
            }
        }
        // Expected output data
        def expPath = tempdir.resolve(Paths.get("SimpleTest", "test method.log"))

        when: "We try running the sample spec"
        def results = specRunner.runClass(SimpleTest)

        then: "The test suite should succeed without error"
        results.testEvents()
            .debug()
            .assertStatistics(stats -> stats.failed(0))

        and: "The log file should have been created by the plugin"
        expPath.toFile().exists()
    }

    def "Test log folder gets recreated"() {
        given: "A temp folder that contains dirty data"
        def testFile = tempdir.resolve("fubar.log").toFile()
        testFile.createNewFile()

        and: "A sample Spock test spec"
        def specRunner = new EmbeddedSpecRunner()
        specRunner.throwFailure = false
        specRunner.configurationScript {
            PerTestLogger {
                logPath tempdir.toString()
            }
        }
        // Expected output data
        def expPath = tempdir.resolve(Paths.get("SimpleTest", "test method.log"))

        when: "We try running the sample spec"
        def results = specRunner.runClass(SimpleTest)

        then: "The test suite should succeed without error"
        results.testEvents()
            .debug()
            .assertStatistics(stats -> stats.failed(0))

        and: "The dirty log data should no longer exist"
        !testFile.exists()

        and: "New test output should be created in its place"
        expPath.toFile().exists()
    }

    def "Test log file gets populated"() {
        given: "A sample Spock test spec"
        def specRunner = new EmbeddedSpecRunner()
        specRunner.throwFailure = false
        specRunner.configurationScript {
            PerTestLogger {
                logPath tempdir.toString()
            }
        }
        // Expected output data
        def expPath = tempdir.resolve(Paths.get("SimpleTest", "test method.log"))

        when: "We try running the sample spec"
        def results = specRunner.runClass(SimpleTest)

        then: "The test suite should succeed without error"
        results.testEvents()
            .debug()
            .assertStatistics(stats -> stats.failed(0))

        and: "The log file should have been created by the plugin"
        expPath.toFile().exists()

        and: "The log file contains the correct output"
        expPath.toFile().text == "${SimpleTest.expectedMessage}\n"
    }

    def "Test log file gets populated from feature setup and teardown"() {
        given: "A sample Spock test spec"
        def specRunner = new EmbeddedSpecRunner()
        specRunner.throwFailure = false
        specRunner.configurationScript {
            PerTestLogger {
                logPath tempdir.toString()
            }
        }
        // Expected output data
        def expPath = tempdir.resolve(Paths.get("FeatureSetupTeardown", "Test Feature.log"))

        when: "We try running the sample spec"
        def results = specRunner.runClass(FeatureSetupTeardown)

        then: "The test suite should succeed without error"
        results.testEvents()
            .debug()
            .assertStatistics(stats -> stats.failed(0))

        and: "The log file should have been created by the plugin"
        expPath.toFile().exists()

        and: "The log file contains the correct output"
        expPath.toFile().text.contains("${expectedMessage}")

        where:
        expectedMessage                      | _
        FeatureSetupTeardown.setupMessage    | _
        FeatureSetupTeardown.teardownMessage | _
    }

    @PendingFeature(reason = "Add support for spec-wide log capture")
    def "Test log file gets populated from specification setup and teardown"() {
        given: "A sample Spock test spec"
        def specRunner = new EmbeddedSpecRunner()
        specRunner.throwFailure = false
        specRunner.configurationScript {
            PerTestLogger {
                logPath tempdir.toString()
            }
        }
        // Expected output data
        def expPath = tempdir.resolve(Paths.get("SpecSetupTeardown", "Test Feature.log"))

        when: "We try running the sample spec"
        def results = specRunner.runClass(SpecSetupTeardown)

        then: "The test suite should succeed without error"
        results.testEvents()
            .debug()
            .assertStatistics(stats -> stats.failed(0))

        and: "The log file should have been created by the plugin"
        expPath.toFile().exists()

        and: "The log file contains the correct output"
        expPath.toFile().text.contains("${expectedMessage}")

        where:
        expectedMessage                   | _
        SpecSetupTeardown.setupMessage    | _
        SpecSetupTeardown.teardownMessage | _
    }

    @PendingFeature(reason = "Add support for namespaces to log path / file")
    def "Test log file clashes between packages"() {
        given: "A sample Spock test spec"
        def specRunner = new EmbeddedSpecRunner()
        specRunner.throwFailure = false
        specRunner.configurationScript {
            PerTestLogger {
                logPath tempdir.toString()
            }
        }
        // Expected output data
        def expPath1 = tempdir.resolve(Paths.get("MyTest", "test method.log"))
        def expPath2 = tempdir.resolve(Paths.get("MyTest", "test method.log"))

        when: "We try running the sample spec"
        def results = specRunner.runClasses(List.of(ca.thefriendlycoder.spockpertestlogger.samples.subpackage1.MyTest, ca.thefriendlycoder.spockpertestlogger.samples.subpackage2.MyTest))

        then: "The test suite should succeed without error"
        results.testEvents()
            .debug()
            .assertStatistics(stats -> stats.failed(0))

        and: "The log file should have been created by the plugin"
        verifyAll {
            expPath1.toFile().exists()
            expPath2.toFile().exists()
        }

        and: "The log file contains the correct output"
        verifyAll {
            expPath1.toFile().text == "${ca.thefriendlycoder.spockpertestlogger.samples.subpackage1.MyTest.expectedMessage}\n"
            expPath2.toFile().text == "${ca.thefriendlycoder.spockpertestlogger.samples.subpackage2.MyTest.expectedMessage}\n"
        }
    }

    @PendingFeature(reason = "Add support for deleting logs for passing tests")
    def "Test log file deletion on success"() {
        given: "A sample Spock test spec"
        def specRunner = new EmbeddedSpecRunner()
        specRunner.throwFailure = false
        specRunner.configurationScript {
            PerTestLogger {
                logPath tempdir.toString()
            }
        }
        // Expected output data
        def expPath1 = tempdir.resolve(Paths.get("PassFailTest", "Passing Test.log"))
        def expPath2 = tempdir.resolve(Paths.get("PassFailTest", "Failing Test.log"))

        when: "We try running the sample spec"
        def results = specRunner.runClass(PassFailTest)

        then: "The test suite should produce one error"
        results.testEvents()
            .debug()
            .assertStatistics(stats -> stats.failed(1))

        and: "The log file should have been created by the plugin"
        verifyAll {
            !expPath1.toFile().exists()
            expPath2.toFile().exists()
        }

        and: "The log file contains the correct output"
        expPath2.toFile().text == "${PassFailTest.failMessage}\n"
    }

    @PendingFeature(reason = "Add support for data driven tests")
    def "Test unique log files for data driven test"() {
        given: "A sample Spock test spec"
        def specRunner = new EmbeddedSpecRunner()
        specRunner.throwFailure = false
        specRunner.configurationScript {
            PerTestLogger {
                logPath tempdir.toString()
            }
        }
        // Expected output data
        def expPath1 = tempdir.resolve(Paths.get(testName, "Data Test1.log"))
        def expPath2 = tempdir.resolve(Paths.get(testName, "Data Test2.log"))

        when: "We try running the sample spec"
        def results = specRunner.runClass(testClass)

        then: "The test suite should produce one error"
        results.testEvents()
            .debug()
            .assertStatistics(stats -> stats.failed(2))

        and: "Two log files should have been created by the plugin"
        verifyAll {
            expPath1.toFile().exists()
            expPath2.toFile().exists()
        }

        and: "Each log file should have the appropriate contents"
        verifyAll {
            expPath1.toFile().text == "${testClass.firstMessage}\n"
            expPath2.toFile().text == "${testClass.secondMessage}\n"
        }

        where:
        testName | testClass
        "SimpleDataTest" | SimpleDataTest
        "SimpleUnrolledDataTest" | SimpleUnrolledDataTest
    }

    @PendingFeature(reason = "Find a way to filter log messages based on thread")
    def "Test log files generate properly when run in parallel"() {
        given: "A sample Spock test spec"
        def specRunner = new EmbeddedSpecRunner()
        specRunner.throwFailure = false
        specRunner.configurationScript {
            runner {
                parallel {
                    enabled true
                }
            }
            PerTestLogger {
                logPath tempdir.toString()
            }
        }
        // Expected output data
        def expPath1 = tempdir.resolve(Paths.get("MultiFeatureTest", "First Test.log"))
        def expPath2 = tempdir.resolve(Paths.get("MultiFeatureTest", "Second Test.log"))
        def expPath3 = tempdir.resolve(Paths.get("MultiFeatureTest", "Third Test.log"))
        def expPath4 = tempdir.resolve(Paths.get("MultiFeatureTest", "Fourth Test.log"))
        def expPath5 = tempdir.resolve(Paths.get("MultiFeatureTest", "Fifth Test.log"))

        when: "We try running the sample spec"
        def results = specRunner.runClass(MultiFeatureTest)

        then: "The test suite should succeed without error"
        results.testEvents()
            .debug()
            .assertStatistics(stats -> stats.failed(0))

        and: "All log files should have been created by the plugin"
        verifyAll {
            expPath1.toFile().exists()
            expPath2.toFile().exists()
            expPath3.toFile().exists()
            expPath4.toFile().exists()
            expPath5.toFile().exists()
        }

        and: "The log files should contains the correct output"
        verifyAll {
            expPath1.toFile().text == "${MultiFeatureTest.expectedMessage1}\n"
            expPath2.toFile().text == "${MultiFeatureTest.expectedMessage2}\n"
            expPath3.toFile().text == "${MultiFeatureTest.expectedMessage3}\n"
            expPath4.toFile().text == "${MultiFeatureTest.expectedMessage4}\n"
            expPath5.toFile().text == "${MultiFeatureTest.expectedMessage5}\n"
        }
    }
}
